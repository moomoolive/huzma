"use strict";import{SemVer as E}from"small-semver";import{NULL_FIELD as d,LATEST_SCHEMA_VERSION as A,FIRST_SCHEMA_VERSION as I,BYTES_NOT_INCLUDED as V}from"./consts";export{NULL_FIELD,LATEST_SCHEMA_VERSION,MANIFEST_FILE_SUFFIX,FIRST_SCHEMA_VERSION,BYTES_NOT_INCLUDED}from"./consts";function y(i){const r=typeof i;return r!=="object"?r:i===null?"null":Array.isArray(i)?"array":"object"}function x(i){if(i.length<1)return"";if(!i.startsWith("/")&&!i.startsWith("./")&&!i.startsWith("../"))return i;const r=i.split("/");let t=-1;for(let s=0;s<r.length;s++){const e=r[s];if(e!==""&&e!=="."&&e!==".."){t=s;break}}return t<0?"":r.slice(t).join("/")}export const NULL_MANIFEST_VERSION="0.0.0";export class HuzmaManifest{schema;name;version;files;entry;invalidation;description;authors;crateLogoUrl;keywords;license;repo;homepageUrl;permissions;metadata;constructor({schema:r=A,name:t="unspecified-name",version:s=NULL_MANIFEST_VERSION,files:e=[],entry:g=d,invalidation:l="default",description:p=d,authors:f=[],crateLogoUrl:m=d,keywords:v=[],license:P=d,repo:k={type:d,url:d},homepageUrl:S=d,permissions:R=[],metadata:n={}}={}){this.homepageUrl=S,this.repo={type:k?.type||"other",url:k?.url||d},this.license=P,this.keywords=v,this.crateLogoUrl=x(m),this.authors=f.map(({name:u=d,email:b=d,url:M=d})=>({name:u,email:b,url:M})),this.description=p,this.invalidation=l,this.files=e.map(u=>typeof u=="string"?{name:u,bytes:0,invalidation:"default"}:u).map(({name:u="",bytes:b=0,invalidation:M="default"})=>({name:x(u),bytes:b,invalidation:M})),this.entry=x(g),this.version=s,this.name=t,this.schema=r;const a=R.map(u=>typeof u=="string"?{key:u,value:[]}:u),o=new Map,h=a.reduce((u,b)=>(o.has(b.key)||(o.set(b.key,1),u.push(b)),u),[]);this.permissions=h,this.metadata=n}}const c=i=>typeof i=="string"?i||d:d,L=(i,r,t,s)=>{const e=typeof i[r];return e===t?!0:(s.push(`${r} should be a ${t}, got "${e}"`),!1)},T=i=>{switch(i){case"purge":case"url-diff":return i;default:return"default"}};export function validateManifest(i){const r={pkg:new HuzmaManifest,errors:[],semanticVersion:E.null()},{pkg:t,errors:s}=r,e=i,g=y(e);if(g!=="object")return s.push(`expected cargo to be type "object" got "${g}"`),r;if(typeof e.schema!="number"||e.schema<I||e.schema>A){const n=new Array(2).fill(0).map((a,o)=>o+1);s.push(`crate version is invalid, got "${e.schema}", valid=${n.join(", ")}`)}t.schema=e.schema||A,L(e,"name","string",s),t.name=c(e.name);let l;L(e,"version","string",s)&&((l=E.fromString(e.version||""))?r.semanticVersion=l:s.push(`${e.version} is not a vaild semantic version`)),t.version=c(e.version);const p=Array.isArray(e.files);p||s.push(`files should be an array, got "${y(e.files)}"`);const f=new Map,m=p?e.files||[]:[];for(let n=0;n<m.length;n++){const a=m[n];typeof a=="string"&&(m[n]={name:a,bytes:0,invalidation:"default"});const o=m[n];if(y(o)!=="object"){s.push(`file ${n} is not an object. Expected an object with a "name" field, got ${y(o)}`);break}if(typeof o?.name!="string"||typeof(o?.invalidation||"")!="string"){s.push(`file ${n} is not a valid file format, file.name and file.invalidation must be a string`);break}const h=x(o.name);if(f.has(h))break;f.set(h,!0),t.files.push({name:h,bytes:Math.max(typeof o.bytes=="number"?o.bytes:V,V),invalidation:T(o?.invalidation||"default")})}const v=e.permissions||[];Array.isArray(v)||s.push(`permissions should be an array, got "${y(e.permissions)}"`);const P=new Map;for(let n=0;n<v.length;n++){const a=v[n],o=y(a);if(o!=="string"&&o!=="object"&&s.push(`permission should be a string or object with "key" & "value" properties. Permission ${n} type=${y(a)}`),typeof a=="string"){if(P.has(a))continue;P.set(a,1),t.permissions.push({key:a,value:[]});continue}if(o!=="object")continue;if(typeof a.key!="string"){s.push(`permission ${n} property "key" is not a string. got = ${y(a.key)}`);continue}const h=a.value||[];if(!Array.isArray(h)){s.push(`permission ${n} property "value" is not an array. got = ${y(a.key)}`);continue}P.has(a.key)||(P.set(a.key,1),t.permissions.push({key:a.key,value:h.filter(u=>typeof u=="string")}))}t.entry=c(e.entry),t.entry!==d&&!f.has(t.entry)&&s.push(`entry must be one of package listed files, got ${t.entry}`),t.invalidation=typeof e.invalidation=="string"?T(e.invalidation):"default",t.description=c(e.description),t.authors=(e.authors||[]).filter(n=>typeof n?.name=="string").map(({name:n="",email:a,url:o})=>({name:n,email:c(a),url:c(o)})),t.crateLogoUrl=x(c(e.crateLogoUrl)),t.keywords=(e.keywords||[]).filter(n=>typeof n=="string"),t.license=c(e.license),t.repo.type=c(e.repo?.type),t.repo.url=c(e.repo?.url),t.homepageUrl=c(e.homepageUrl),e.metadata=e.metadata||{},y(e.metadata)!=="object"&&(s.push(`metadata should be a record of strings, got "${y(e.metadata)}"`),e.metadata={});const k={},S=e.metadata||{},R=Object.keys(e.metadata||{});for(let n=0;n<R.length;n++){const a=R[n],o=S[a];if(typeof o!="string"){s.push(`meta should be a record of strings, got type "${y(o)}" for property "${a}" of meta`);continue}k[a]=o}return t.metadata=k,r}export function manifestIsUpdatable(i,r){const t=validateManifest(r),s=validateManifest(i),e={oldManifest:t,newManifest:s,updateAvailable:!1},g=e.oldManifest.errors.length>0,l=e.oldManifest.errors.length>0;if(g||l)return e;const p=t.pkg.version===NULL_MANIFEST_VERSION,f=s.pkg.version===NULL_MANIFEST_VERSION;if(p&&f)return e;if(f)return e;if(p&&!f)return e.updateAvailable=!0,e;const m=t.semanticVersion,v=s.semanticVersion;return e.updateAvailable=v.isGreater(m),e}export class HuzmaUpdateDetails{add;delete;constructor(r,t){this.add=r,this.delete=t}}export function diffManifestFiles(i,r,t){const s=new HuzmaUpdateDetails([],[]),e={};for(let l=0;l<i.files.length;l++){const{name:p,invalidation:f}=i.files[l];if(i.entry!==d&&p===i.entry&&f==="default"){e[p]="purge";continue}e[p]=f==="default"?t:f}const g={};for(let l=0;l<r.files.length;l++){const{name:p}=r.files[l];g[p]=!0}for(let l=0;l<i.files.length;l++){const{name:p,bytes:f}=i.files[l];(!g[p]||e[p]==="purge")&&s.add.push({name:p,bytes:f})}for(let l=0;l<r.files.length;l++){const{name:p,bytes:f}=r.files[l],m=e[p];(!m||m==="purge")&&s.delete.push({name:p,bytes:f})}return s}
//# sourceMappingURL=index.js.map
