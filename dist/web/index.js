"use strict";import{SemVer as V}from"small-semver";export const MANIFEST_FILE_SUFFIX=".huzma.json",NULL_FIELD="",FIRST_SCHEMA_VERSION=1,LATEST_SCHEMA_VERSION=2,BYTES_NOT_INCLUDED=-1;function d(t){const a=typeof t;return a!=="object"?a:t===null?"null":Array.isArray(t)?"array":"object"}function x(t){if(t.length<1)return"";if(!t.startsWith("/")&&!t.startsWith("./")&&!t.startsWith("../"))return t;const a=t.split("/");let s=-1;for(let i=0;i<a.length;i++){const e=a[i];if(e!==""&&e!=="."&&e!==".."){s=i;break}}return s<0?"":a.slice(s).join("/")}export const NULL_MANIFEST_VERSION="0.0.0";export class HuzmaManifest{schema;name;version;files;entry;invalidation;description;authors;crateLogoUrl;keywords;license;repo;homepageUrl;permissions;metadata;constructor({schema:a=LATEST_SCHEMA_VERSION,name:s="unspecified-name",version:i=NULL_MANIFEST_VERSION,files:e=[],entry:m=NULL_FIELD,invalidation:l="default",description:u=NULL_FIELD,authors:f=[],crateLogoUrl:c=NULL_FIELD,keywords:h=[],license:b=NULL_FIELD,repo:v={type:NULL_FIELD,url:NULL_FIELD},homepageUrl:P=NULL_FIELD,permissions:R=[],metadata:k={}}={}){this.homepageUrl=P,this.repo={type:v?.type||"other",url:v?.url||NULL_FIELD},this.license=b,this.keywords=h,this.crateLogoUrl=x(c),this.authors=f.map(({name:p=NULL_FIELD,email:g=NULL_FIELD,url:M=NULL_FIELD})=>({name:p,email:g,url:M})),this.description=u,this.invalidation=l,this.files=e.map(p=>typeof p=="string"?{name:p,bytes:0,invalidation:"default"}:p).map(({name:p="",bytes:g=0,invalidation:M="default"})=>({name:x(p),bytes:g,invalidation:M})),this.entry=x(m),this.version=i,this.name=s,this.schema=a;const n=R.map(p=>typeof p=="string"?{key:p,value:[]}:p),r=new Map,o=n.reduce((p,g)=>(r.has(g.key)||(r.set(g.key,1),p.push(g)),p),[]);this.permissions=o,this.metadata=k}}const y=t=>typeof t=="string"&&t||NULL_FIELD,A=(t,a,s,i)=>{const e=typeof t[a];return e===s?!0:(i.push(`${a} should be a ${s}, got "${e}"`),!1)},L=t=>{switch(t){case"purge":case"url-diff":return t;default:return"default"}},E="https://example.com";function S(t){try{return t===encodeURIComponent(t)&&!!new URL(t,E)}catch{return!1}}export function validateManifest(t){const a={pkg:new HuzmaManifest,errors:[],semanticVersion:V.null()},{pkg:s,errors:i}=a,e=t,m=d(e);if(m!=="object")return i.push(`expected cargo to be type "object" got "${m}"`),a;if(typeof e.schema!="number"||e.schema<FIRST_SCHEMA_VERSION||e.schema>LATEST_SCHEMA_VERSION){const n=new Array(2).fill(0).map((r,o)=>o+1);i.push(`crate version is invalid, got "${e.schema}", valid=${n.join(", ")}`)}s.schema=e.schema||LATEST_SCHEMA_VERSION,A(e,"name","string",i),s.name=y(e.name);let l;A(e,"version","string",i)&&((l=V.fromString(e.version||""))?a.semanticVersion=l:i.push(`${e.version} is not a vaild semantic version`)),s.version=y(e.version);const u=e.files===void 0?[]:e.files,f=Array.isArray(u);f||i.push(`files should be an array, got "${d(u)}"`);const c=new Map,h=f?u:[];for(let n=0;n<h.length;n++){const r=h[n];typeof r=="string"&&(S(r)||i.push(`files should be a valid url. got "${r}"`),h[n]={name:r,bytes:0,invalidation:"default"});const o=h[n];if(d(o)!=="object"){i.push(`file ${n} is not an object. Expected an object with a "name" field, got ${d(o)}`);break}if(typeof o?.name!="string"||!S(o.name)){i.push(`file ${n} is not a valid file format, file.name and must be a valid absolute or relative url. got ${o.name}`);break}if(typeof(o?.invalidation||"")!="string"){i.push(`file ${n} is not a valid file format, file.invalidation must be a string`);break}const p=x(o.name);if(c.has(p))break;c.set(p,!0),s.files.push({name:p,bytes:Math.max(typeof o.bytes=="number"?o.bytes:BYTES_NOT_INCLUDED,BYTES_NOT_INCLUDED),invalidation:L(o?.invalidation||"default")})}const b=e.permissions||[];Array.isArray(b)||i.push(`permissions should be an array, got "${d(e.permissions)}"`);const v=new Map;for(let n=0;n<b.length;n++){const r=b[n],o=d(r);if(o!=="string"&&o!=="object"&&i.push(`permission should be a string or object with "key" & "value" properties. Permission ${n} type=${d(r)}`),typeof r=="string"){if(v.has(r))continue;v.set(r,1),s.permissions.push({key:r,value:[]});continue}if(o!=="object")continue;if(typeof r.key!="string"){i.push(`permission ${n} property "key" is not a string. got = ${d(r.key)}`);continue}const p=r.value||[];if(!Array.isArray(p)){i.push(`permission ${n} property "value" is not an array. got = ${d(r.key)}`);continue}v.has(r.key)||(v.set(r.key,1),s.permissions.push({key:r.key,value:p.filter(g=>typeof g=="string")}))}e.entry=y(e.entry),A(e,"entry","string",i),e.entry!==NULL_FIELD&&!S(e.entry)&&i.push(`entry field must be a valid relative or absolute url. got "${s.entry}"`),s.entry=e.entry,s.invalidation=typeof e.invalidation=="string"?L(e.invalidation):"default",s.description=y(e.description),s.authors=(e.authors||[]).filter(n=>typeof n?.name=="string").map(({name:n="",email:r,url:o})=>({name:n,email:y(r),url:y(o)})),s.crateLogoUrl=x(y(e.crateLogoUrl)),s.keywords=(e.keywords||[]).filter(n=>typeof n=="string"),s.license=y(e.license),s.repo.type=y(e.repo?.type),s.repo.url=y(e.repo?.url),s.homepageUrl=y(e.homepageUrl),e.metadata=e.metadata||{},d(e.metadata)!=="object"&&(i.push(`metadata should be a record of strings, got "${d(e.metadata)}"`),e.metadata={});const P={},R=e.metadata||{},k=Object.keys(e.metadata||{});for(let n=0;n<k.length;n++){const r=k[n],o=R[r];if(typeof o!="string"){i.push(`meta should be a record of strings, got type "${d(o)}" for property "${r}" of meta`);continue}P[r]=o}return s.metadata=P,a}export function manifestIsUpdatable(t,a){const s=validateManifest(a),i=validateManifest(t),e={oldManifest:s,newManifest:i,updateAvailable:!1},m=e.oldManifest.errors.length>0,l=e.oldManifest.errors.length>0;if(m||l)return e;const u=s.pkg.version===NULL_MANIFEST_VERSION,f=i.pkg.version===NULL_MANIFEST_VERSION;if(u&&f)return e;if(f)return e;if(u&&!f)return e.updateAvailable=!0,e;const c=s.semanticVersion,h=i.semanticVersion;return e.updateAvailable=h.isGreater(c),e}export class HuzmaUpdateDetails{add;delete;constructor(a,s){this.add=a,this.delete=s}}export function diffManifestFiles(t,a,s){const i=new HuzmaUpdateDetails([],[]),e={};for(let l=0;l<t.files.length;l++){const{name:u,invalidation:f}=t.files[l];if(t.entry!==NULL_FIELD&&u===t.entry&&f==="default"){e[u]="purge";continue}e[u]=f==="default"?s:f}const m={};for(let l=0;l<a.files.length;l++){const{name:u}=a.files[l];m[u]=!0}for(let l=0;l<t.files.length;l++){const{name:u,bytes:f}=t.files[l];(!m[u]||e[u]==="purge")&&i.add.push({name:u,bytes:f})}for(let l=0;l<a.files.length;l++){const{name:u,bytes:f}=a.files[l],c=e[u];(!c||c==="purge")&&i.delete.push({name:u,bytes:f})}return i}
//# sourceMappingURL=index.js.map
