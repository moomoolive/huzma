{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["import {SemVer} from \"small-semver\"\nimport {\n    NULL_FIELD,\n    ALL_SCHEMA_VERSIONS,\n    LATEST_SCHEMA_VERSION\n} from \"./consts\"\n\nexport {\n    NULL_FIELD,\n    ALL_SCHEMA_VERSIONS,\n    LATEST_SCHEMA_VERSION,\n    MANIFEST_FILE_SUFFIX\n} from \"./consts\"\n\ntype ExpandedInbuiltTypes = (\n    \"string\" \n    | \"number\" \n    | \"bigint\" \n    | \"boolean\" \n    | \"symbol\" \n    | \"undefined\" \n    | \"function\" \n    | \"object\" \n    | \"null\" \n    | \"array\"\n)\n\nfunction type(val: unknown): ExpandedInbuiltTypes {\n    const t = typeof val\n    if (t !== \"object\") {\n        return t\n    } else if (val === null) {\n        return \"null\"\n    } else if (Array.isArray(val)) {\n        return \"array\"\n    } else {\n        return \"object\"\n    }\n}\n\nfunction stripRelativePath(url: string): string {\n    if (url.length < 1) {\n        return \"\"\n    }\n    if (\n        !url.startsWith(\"/\")\n        && !url.startsWith(\"./\") \n        && !url.startsWith(\"../\")\n    ) {\n        return url\n    }\n    const split = url.split(\"/\")\n    let urlStart = -1\n    for (let i = 0; i < split.length; i++) {\n        const path = split[i]\n        if (path !== \"\" && path !== \".\" && path !== \"..\") {\n            urlStart = i\n            break\n        }\n    }\n    if (urlStart < 0) {\n        return \"\"\n    }\n    return split.slice(urlStart).join(\"/\")\n}\n\nexport type SchemaVersion = keyof typeof ALL_SCHEMA_VERSIONS\nexport type NullField = typeof NULL_FIELD\nexport type RepoType = \"git\" | \"other\" | NullField\nexport type ValidDefaultStrategies = (\"url-diff\" | \"purge\")\nexport type InvalidationStrategy = ValidDefaultStrategies | \"default\"\n\ntype PermissionsListRaw = ReadonlyArray<\n    string | {key: string, value: Array<string> | ReadonlyArray<string>}\n>\n\ntype FillEmptyPermissions<\n    P extends PermissionsListRaw\n> = {\n    [index in keyof P]: P[index] extends string\n        ?  {key: P[index], value: string[]}\n        :  P[index] extends {\n                key: infer Key, \n                value: Array<infer Value> | ReadonlyArray<infer Value>\n        }\n            ?  {key: Key, value: Value[]}\n            : never\n}\n\ntype FillEmptyPermissionsOptional<P extends PermissionsListRaw> = {\n    [index in keyof P]: P[index] extends string\n        ?  P[index] | {key: P[index], value: string[]}\n        :  P[index] extends {\n                key: infer Key, \n                value: Array<infer Value> | ReadonlyArray<infer Value>\n        }\n            ? Key | {key: Key, value: Value[]}\n            : never\n}\n\ntype PermissionsListOptions<\n    P extends PermissionsListRaw = {key: string, value: string[]}[]\n> = Array<FillEmptyPermissionsOptional<P>[number]>\n\nexport type PermissionsList<\n    P extends PermissionsListRaw = {key: string, value: string[]}[]\n> = Array<FillEmptyPermissions<P>[number]>\n\ntype HuzmaManifestPartial= Partial<\n    Omit<HuzmaManifest, \"files\" | \"authors\" | \"repo\" | \"permissions\">\n>\n\ntype ManifestOptions<\n    Permissions extends PermissionsListRaw = ReadonlyArray<{key: string, value: string[]}>\n> = (\n    HuzmaManifestPartial & Partial<{\n        authors: Array<Partial<{\n            name: string, \n            email: string, \n            url: string\n        }>>\n        files: Array<string> | Array<Partial<{\n            name: string,   \n            bytes: number,\n            invalidation: InvalidationStrategy\n        }>>\n        repo: Partial<{ type: RepoType, url: string }>\n        permissions: PermissionsListOptions<Permissions>\n        metadata: Record<string, string>\n    }>\n)\n\nexport const NULL_MANIFEST_VERSION = \"0.0.0\"\n\nexport class HuzmaManifest<\n    Permissions extends PermissionsListRaw = ReadonlyArray<{key: string, value: string[]}>\n> {\n    // required fields\n    schema: SchemaVersion\n    name: string\n    version: string\n    files: Array<{\n        name: string, \n        bytes: number,\n        invalidation: InvalidationStrategy\n    }>\n\n    // optional fields\n    entry: string\n    invalidation: InvalidationStrategy\n    description: string\n    authors: Array<{ name: string, email: string, url: string }>\n    crateLogoUrl: string\n    keywords: string[]\n    license: string\n    repo: {type: RepoType, url: string}\n    homepageUrl: string\n    permissions: PermissionsList<Permissions>\n    metadata: Record<string, string>\n\n    constructor({\n        schema = \"0.1.0\",\n        name = \"unspecified-name\",\n        version = NULL_MANIFEST_VERSION,\n        files = [],\n\n        // optionalfields\n        entry = NULL_FIELD,\n        invalidation = \"default\",\n        description = NULL_FIELD,\n        authors = [],\n        crateLogoUrl = NULL_FIELD,\n        keywords = [],\n        license = NULL_FIELD,\n        repo = {type: NULL_FIELD, url: NULL_FIELD},\n        homepageUrl = NULL_FIELD,\n        permissions = [],\n        metadata = {}\n    }: ManifestOptions<Permissions> = {}) {\n        this.homepageUrl = homepageUrl\n        this.repo = {\n            type: repo?.type || \"other\",\n            url: repo?.url || NULL_FIELD\n        }\n        this.license = license\n        this.keywords = keywords\n        this.crateLogoUrl = stripRelativePath(crateLogoUrl)\n        this.authors = authors.map(({\n            name = NULL_FIELD, \n            email = NULL_FIELD, \n            url = NULL_FIELD\n        }) => ({\n            name, email, url\n        }))\n        this.description = description\n        this.invalidation = invalidation\n        this.files = files\n            .map((file) => typeof file === \"string\" \n                ? {name: file, bytes: 0, invalidation: \"default\"} as const\n                : file\n            )\n            .map(({\n                name = \"\", bytes = 0, invalidation = \"default\"\n            }) => ({\n                name: stripRelativePath(name), \n                bytes, \n                invalidation\n            }))\n        this.entry = stripRelativePath(entry)\n        this.version = version\n        this.name = name\n        this.schema = schema\n        const permissionsExpanded = permissions.map((permission) => {\n            if (typeof permission === \"string\") {\n                return {key: permission, value: []}\n            }\n            return permission\n        }) as PermissionsList<Permissions>\n        const permissionsMap = new Map<string, number>()\n        const noDuplicates = permissionsExpanded.reduce((permissionsArray, next) => {\n            if (permissionsMap.has(next.key as string)) {\n                return permissionsArray\n            }\n            permissionsMap.set(next.key as string, 1)\n            permissionsArray.push(next)\n            return permissionsArray\n        }, [] as PermissionsList<Permissions>)\n        this.permissions = noDuplicates\n        this.metadata = metadata\n    }\n}\n\nconst orNull = <T extends string>(str?: T) => typeof str === \"string\" ? str || NULL_FIELD : NULL_FIELD\n\nconst typevalid = <T extends Record<string, unknown>>(\n    obj: T,\n    key: keyof T,\n    type: \"string\" | \"object\",\n    errs: string[]\n) => {\n    const t = typeof obj[key]\n    if (t === type) {\n        return true\n    }\n    errs.push(`${key as string} should be a ${type}, got \"${t}\"`)\n    return false\n}\n\nexport type ValidatedCodeManfiest = {\n    pkg: HuzmaManifest,\n    errors: string [],\n    semanticVersion: SemVer\n}\n\nconst toInvalidation = (invalidation: string) => {\n    switch (invalidation) {\n        case \"purge\":\n        case \"url-diff\":\n            return invalidation\n        default:\n            return \"default\"\n    }\n}\n\nexport function validateManifest<T>(cargo: T): ValidatedCodeManfiest {\n    \n    const out: ValidatedCodeManfiest = {\n        pkg: new HuzmaManifest(),\n        errors: [],\n        semanticVersion: SemVer.null()\n    }\n    const {pkg, errors} = out\n    const c = cargo as ManifestOptions\n    const baseType = type(c)\n    if (baseType !== \"object\") {\n        errors.push(`expected cargo to be type \"object\" got \"${baseType}\"`)\n        return out\n    }\n    if (!ALL_SCHEMA_VERSIONS[c.schema || \"\" as SchemaVersion]) {\n        errors.push(`crate version is invalid, got \"${c.schema}\", valid=${Object.keys(ALL_SCHEMA_VERSIONS).join()}`)\n    }\n    pkg.schema = c.schema || LATEST_SCHEMA_VERSION\n\n    if (!typevalid(c, \"name\", \"string\", errors)) {}\n    pkg.name = orNull(c.name)\n\n    let semverTmp: SemVer | null\n    if (!typevalid(c, \"version\", \"string\", errors)) {\n\n    } else if (!(semverTmp = SemVer.fromString(c.version || \"\"))) {\n        errors.push(`${c.version} is not a vaild semantic version`)\n    } else {\n        out.semanticVersion = semverTmp\n    }\n    pkg.version = orNull(c.version)\n\n    const filesIsArray = Array.isArray(c.files)\n    if (!filesIsArray) {\n        errors.push(`files should be an array, got \"${type(c.files)}\"`)\n    }\n    \n    const fileRecord: Record<string, boolean> = {}\n    const files = !filesIsArray ? [] : c.files || []\n    for (let i = 0; i < files.length; i++) {\n        const preFile = files[i]\n        if (typeof preFile === \"string\") {\n            files[i] = {name: preFile, bytes: 0, invalidation: \"default\"}\n        }\n        const file = files[i] as Partial<{name: string, bytes: 0, invalidation: string}>\n        if (type(file) !== \"object\") {\n            errors.push(`file ${i} is not an object. Expected an object with a \"name\" field, got ${type(file)}`)\n            break\n        }\n        if (\n            typeof file?.name !== \"string\" \n            || typeof (file?.invalidation || \"\") !== \"string\" \n        ) {\n            errors.push(`file ${i} is not a valid file format, file.name and file.invalidation must be a string`)\n            break\n        }\n        const stdName = stripRelativePath(file.name)\n        if (\n            // ignore cross-origin\n            stdName.startsWith(\"https://\")\n            || stdName.startsWith(\"http://\")\n            // ignore duplicate files\n            || fileRecord[stdName]\n        ) {\n            break\n        }\n        fileRecord[stdName] = true\n        pkg.files.push({\n            name: stdName,\n            bytes: Math.max(\n                typeof file.bytes === \"number\" ? file.bytes : 0, \n                0\n            ),\n            invalidation: toInvalidation(\n                file?.invalidation || \"default\"\n            )\n        })\n    }\n\n    const permissions = c.permissions || []\n    if (!Array.isArray(permissions)) {\n        errors.push(`permissions should be an array, got \"${type(c.permissions)}\"`)\n    }\n\n    const permissionsMap = new Map<string, number>()\n    for (let i = 0; i < permissions.length; i++) {\n        const permission = permissions[i]\n        const permissionType = type(permission)\n        if (permissionType !== \"string\" && permissionType !== \"object\") {\n            errors.push(`permission should be a string or object with \"key\" & \"value\" properties. Permission ${i} type=${type(permission)}`)\n        }\n\n        if (typeof permission === \"string\") {\n            if (permissionsMap.has(permission)) {\n                continue\n            }\n            permissionsMap.set(permission, 1)\n            pkg.permissions.push({key: permission, value: []})\n            continue\n        }\n        if (permissionType !== \"object\") {\n            continue\n        }\n        if (typeof permission.key !== \"string\") {\n            errors.push(`permission ${i} property \"key\" is not a string. got = ${type(permission.key)}`)\n            continue\n        }\n        const value = permission.value || []\n        if (!Array.isArray(value)) {\n            errors.push(`permission ${i} property \"value\" is not an array. got = ${type(permission.key)}`)\n            continue\n        }\n        if (permissionsMap.has(permission.key)) {\n            continue\n        }\n        permissionsMap.set(permission.key, 1)\n        pkg.permissions.push({\n            key: permission.key, \n            value: value.filter((val) => typeof val === \"string\")\n        })\n    }\n\n    pkg.entry = orNull(c.entry)\n    if (pkg.entry !== NULL_FIELD && !fileRecord[pkg.entry]) {\n        errors.push(`entry must be one of package listed files, got ${pkg.entry}`)\n    }\n\n    pkg.invalidation = typeof c.invalidation === \"string\"\n        ? toInvalidation(c.invalidation)\n        : \"default\"\n    pkg.description = orNull(c.description)\n    pkg.authors = (c.authors || [])\n        .filter(a => typeof a?.name === \"string\")\n        .map(({name = \"\", email, url}) => ({\n            name,  email: orNull(email), url: orNull(url)\n        }))\n    pkg.crateLogoUrl = stripRelativePath(orNull(c.crateLogoUrl))\n    pkg.keywords = (c.keywords || [])\n        .filter(w => typeof w === \"string\")\n    pkg.license = orNull(c.license)\n    pkg.repo.type = orNull(c.repo?.type)\n    pkg.repo.url = orNull(c.repo?.url)\n    pkg.homepageUrl = orNull(c.homepageUrl)\n\n    c.metadata = c.metadata || {}\n    if (type(c.metadata) !== \"object\") {\n        errors.push(`metadata should be a record of strings, got \"${type(c.metadata)}\"`)\n        c.metadata = {}\n    }\n\n    const meta: Record<string, string> = {}\n    const candidate = c.metadata || {}\n    const metaKeys = Object.keys(c.metadata || {})\n    for (let i = 0; i < metaKeys.length; i++) {\n        const key = metaKeys[i]\n        const value = candidate[key]\n        if (typeof value !== \"string\") {\n            errors.push(`meta should be a record of strings, got type \"${type(value)}\" for property \"${key}\" of meta`)\n            continue\n        }\n        meta[key] = value\n    }\n    pkg.metadata = meta\n    return out\n}\n\nexport type ManifestUpdateResponse = {\n    oldManifest: ValidatedCodeManfiest\n    newManifest: ValidatedCodeManfiest\n    updateAvailable: boolean\n}\n\nexport function manifestIsUpdatable(\n    newManifest: unknown, \n    oldManifest: unknown\n): ManifestUpdateResponse {\n    const validatedOld = validateManifest(oldManifest)\n    const validatedNew = validateManifest(newManifest)\n    const out = {\n        oldManifest: validatedOld, \n        newManifest: validatedNew,\n        updateAvailable: false\n    }\n    const oldErrs = out.oldManifest.errors.length > 0\n    const newErrs = out.oldManifest.errors.length > 0\n    if (oldErrs || newErrs) {\n        return out\n    }\n    const oldVersionIsNull = validatedOld.pkg.version === NULL_MANIFEST_VERSION\n    const newVersionIsNull = validatedNew.pkg.version === NULL_MANIFEST_VERSION\n    if (oldVersionIsNull && newVersionIsNull) {\n        return out\n    } else if (newVersionIsNull) {\n        return out\n    } else if (oldVersionIsNull && !newVersionIsNull) {\n        out.updateAvailable = true\n        return out\n    }\n    const oldSemVer = validatedOld.semanticVersion\n    const newSemver = validatedNew.semanticVersion\n    out.updateAvailable = newSemver.isGreater(oldSemVer)\n    return out\n}\n\ntype FileRef = {\n    name: string, \n    bytes: number\n}\n\nclass HuzmaUpdateDetails {\n    add: FileRef[]\n    delete: FileRef[]\n\n    constructor(addFiles: FileRef[], deleteFiles: FileRef[]) {\n        this.add = addFiles\n        this.delete = deleteFiles\n    }\n}\n\nexport function diffManifestFiles(\n    newCargo: HuzmaManifest, \n    oldCargo: HuzmaManifest,\n    defaultInvalidation: ValidDefaultStrategies\n): HuzmaUpdateDetails {\n    const updates = new HuzmaUpdateDetails([], [])\n    const newFiles: Record<string, ValidDefaultStrategies> = {}\n    for (let i = 0; i < newCargo.files.length; i++) {\n        const {name, invalidation} = newCargo.files[i]\n        if (\n            newCargo.entry !== NULL_FIELD \n            && name === newCargo.entry\n            && invalidation === \"default\"\n        ) {\n            newFiles[name] = \"purge\"\n            continue\n        }\n        newFiles[name] = invalidation === \"default\"\n            ? defaultInvalidation\n            : invalidation\n    }\n\n    const oldFiles: Record<string, boolean> = {}\n    for (let i = 0; i < oldCargo.files.length; i++) {\n        const {name} = oldCargo.files[i]\n        oldFiles[name] = true\n    }\n\n    for (let i = 0; i < newCargo.files.length; i++) {\n        const {name, bytes} = newCargo.files[i]\n        if (!oldFiles[name] || newFiles[name] === \"purge\") {\n            updates.add.push({name, bytes})\n        }\n    }\n\n    for (let i = 0; i < oldCargo.files.length; i++) {\n        const {name, bytes} = oldCargo.files[i]\n        const invalidation = newFiles[name]\n        if (!invalidation || invalidation === \"purge\") {\n            updates.delete.push({name, bytes})\n        }\n    }\n    return updates\n}"],
  "mappings": "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",
  "names": ["SemVer", "NULL_FIELD", "ALL_SCHEMA_VERSIONS", "LATEST_SCHEMA_VERSION", "type", "val", "t", "stripRelativePath", "url", "split", "urlStart", "i", "path", "schema", "name", "version", "files", "entry", "invalidation", "description", "authors", "crateLogoUrl", "keywords", "license", "repo", "homepageUrl", "permissions", "metadata", "email", "file", "bytes", "permissionsExpanded", "permission", "permissionsMap", "noDuplicates", "permissionsArray", "next", "orNull", "str", "typevalid", "obj", "key", "errs", "toInvalidation", "cargo", "out", "pkg", "errors", "c", "baseType", "semverTmp", "filesIsArray", "fileRecord", "preFile", "stdName", "permissionType", "value", "a", "w", "meta", "candidate", "metaKeys", "newManifest", "oldManifest", "validatedOld", "validatedNew", "oldErrs", "newErrs", "oldVersionIsNull", "newVersionIsNull", "oldSemVer", "newSemver", "HuzmaUpdateDetails", "addFiles", "deleteFiles", "newCargo", "oldCargo", "defaultInvalidation", "updates", "newFiles", "oldFiles"]
}
