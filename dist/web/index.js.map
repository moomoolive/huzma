{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["import {SemVer} from \"small-semver\"\n\nexport const MANIFEST_FILE_SUFFIX = \".huzma.json\"\nexport const NULL_FIELD = \"\"\nexport const FIRST_SCHEMA_VERSION = 1\nexport const LATEST_SCHEMA_VERSION = 2\nexport const BYTES_NOT_INCLUDED = -1\n\nexport type {HuzmaCliConfig} from \"./cli\"\n\ntype ExpandedInbuiltTypes = (\n    \"string\" \n    | \"number\" \n    | \"bigint\" \n    | \"boolean\" \n    | \"symbol\" \n    | \"undefined\" \n    | \"function\" \n    | \"object\" \n    | \"null\" \n    | \"array\"\n)\n\nfunction betterTypeof(val: unknown): ExpandedInbuiltTypes {\n    const t = typeof val\n    if (t !== \"object\") {\n        return t\n    } else if (val === null) {\n        return \"null\"\n    } else if (Array.isArray(val)) {\n        return \"array\"\n    } else {\n        return \"object\"\n    }\n}\n\nfunction stripRelativePath(url: string): string {\n    if (url.length < 1) {\n        return \"\"\n    }\n    if (\n        !url.startsWith(\"/\")\n        && !url.startsWith(\"./\") \n        && !url.startsWith(\"../\")\n    ) {\n        return url\n    }\n    const split = url.split(\"/\")\n    let urlStart = -1\n    for (let i = 0; i < split.length; i++) {\n        const path = split[i]\n        if (path !== \"\" && path !== \".\" && path !== \"..\") {\n            urlStart = i\n            break\n        }\n    }\n    if (urlStart < 0) {\n        return \"\"\n    }\n    return split.slice(urlStart).join(\"/\")\n}\n\nexport type SchemaVersion = (\n    typeof FIRST_SCHEMA_VERSION\n    | typeof LATEST_SCHEMA_VERSION\n)\nexport type NullField = typeof NULL_FIELD\nexport type RepoType = \"git\" | \"other\" | NullField\nexport type ValidDefaultStrategies = (\"url-diff\" | \"purge\")\nexport type InvalidationStrategy = ValidDefaultStrategies | \"default\"\n\nexport type PermissionsListRaw = ReadonlyArray<\n    string | {key: string, value: Array<string> | ReadonlyArray<string>}\n>\n\ntype FillEmptyPermissions<\n    P extends PermissionsListRaw\n> = {\n    [index in keyof P]: P[index] extends string\n        ?  {key: P[index], value: string[]}\n        :  P[index] extends {\n                key: infer Key, \n                value: Array<infer Value> | ReadonlyArray<infer Value>\n        }\n            ?  {key: Key, value: Value[]}\n            : never\n}\n\ntype FillEmptyPermissionsOptional<P extends PermissionsListRaw> = {\n    [index in keyof P]: P[index] extends string\n        ?  P[index] | {key: P[index], value: string[]}\n        :  P[index] extends {\n                key: infer Key, \n                value: Array<infer Value> | ReadonlyArray<infer Value>\n        }\n            ? Key | {key: Key, value: Value[]}\n            : never\n}\n\nexport type PermissionsListOptions<\n    P extends PermissionsListRaw = {key: string, value: string[]}[]\n> = Array<FillEmptyPermissionsOptional<P>[number]>\n\nexport type PermissionsList<\n    P extends PermissionsListRaw = {key: string, value: string[]}[]\n> = Array<FillEmptyPermissions<P>[number]>\n\nexport type HuzmaManifestPartial= Partial<\n    Omit<HuzmaManifest, \"files\" | \"authors\" | \"repo\" | \"permissions\">\n>\n\nexport type ManifestOptions<\n    Permissions extends PermissionsListRaw = ReadonlyArray<{key: string, value: string[]}>\n> = (\n    HuzmaManifestPartial & Partial<{\n        authors: Array<Partial<{\n            name: string, \n            email: string, \n            url: string\n        }>>\n        files: Array<string> | Array<Partial<{\n            name: string,   \n            bytes: number,\n            invalidation: InvalidationStrategy\n        }>>\n        repo: Partial<{ type: RepoType, url: string }>\n        permissions: PermissionsListOptions<Permissions>\n        metadata: Record<string, string>\n    }>\n)\n\nexport const NULL_MANIFEST_VERSION = \"0.0.0\"\n\nexport class HuzmaManifest<\n    Permissions extends PermissionsListRaw = ReadonlyArray<{key: string, value: string[]}>\n> {\n    // required fields\n    schema: SchemaVersion\n    name: string\n    version: string\n    \n    // optional fields\n    files: Array<{\n        name: string, \n        bytes: number,\n        invalidation: InvalidationStrategy\n    }>\n    entry: string\n    invalidation: InvalidationStrategy\n    description: string\n    authors: Array<{ name: string, email: string, url: string }>\n    crateLogoUrl: string\n    keywords: string[]\n    license: string\n    repo: {type: RepoType, url: string}\n    homepageUrl: string\n    permissions: PermissionsList<Permissions>\n    metadata: Record<string, string>\n\n    constructor({\n        schema = LATEST_SCHEMA_VERSION,\n        name = \"unspecified-name\",\n        version = NULL_MANIFEST_VERSION,\n\n        // optional fields\n        files = [],\n        entry = NULL_FIELD,\n        invalidation = \"default\",\n        description = NULL_FIELD,\n        authors = [],\n        crateLogoUrl = NULL_FIELD,\n        keywords = [],\n        license = NULL_FIELD,\n        repo = {type: NULL_FIELD, url: NULL_FIELD},\n        homepageUrl = NULL_FIELD,\n        permissions = [],\n        metadata = {}\n    }: ManifestOptions<Permissions> = {}) {\n        this.homepageUrl = homepageUrl\n        this.repo = {\n            type: repo?.type || \"other\",\n            url: repo?.url || NULL_FIELD\n        }\n        this.license = license\n        this.keywords = keywords\n        this.crateLogoUrl = stripRelativePath(crateLogoUrl)\n        this.authors = authors.map(({\n            name = NULL_FIELD, \n            email = NULL_FIELD, \n            url = NULL_FIELD\n        }) => ({\n            name, email, url\n        }))\n        this.description = description\n        this.invalidation = invalidation\n        this.files = files\n            .map((file) => typeof file === \"string\" \n                ? {name: file, bytes: 0, invalidation: \"default\"} as const\n                : file\n            )\n            .map(({\n                name = \"\", bytes = 0, invalidation = \"default\"\n            }) => ({\n                name: stripRelativePath(name), \n                bytes, \n                invalidation\n            }))\n        this.entry = stripRelativePath(entry)\n        this.version = version\n        this.name = name\n        this.schema = schema\n        const permissionsExpanded = permissions.map((permission) => {\n            if (typeof permission === \"string\") {\n                return {key: permission, value: []}\n            }\n            return permission\n        }) as PermissionsList<Permissions>\n        const permissionsMap = new Map<string, number>()\n        const noDuplicates = permissionsExpanded.reduce((permissionsArray, next) => {\n            if (permissionsMap.has(next.key as string)) {\n                return permissionsArray\n            }\n            permissionsMap.set(next.key as string, 1)\n            permissionsArray.push(next)\n            return permissionsArray\n        }, [] as PermissionsList<Permissions>)\n        this.permissions = noDuplicates\n        this.metadata = metadata\n    }\n}\n\nconst orNull = <T extends string>(str?: T) => typeof str === \"string\" ? str || NULL_FIELD : NULL_FIELD\n\nconst typevalid = <T extends Record<string, unknown>>(\n    obj: T,\n    key: keyof T,\n    type: \"string\" | \"object\",\n    errs: string[]\n) => {\n    const t = typeof obj[key]\n    if (t === type) {\n        return true\n    }\n    errs.push(`${key as string} should be a ${type}, got \"${t}\"`)\n    return false\n}\n\nexport type ValidatedCodeManfiest = {\n    pkg: HuzmaManifest,\n    errors: string [],\n    semanticVersion: SemVer\n}\n\nconst toInvalidation = (invalidation: string) => {\n    switch (invalidation) {\n        case \"purge\":\n        case \"url-diff\":\n            return invalidation\n        default:\n            return \"default\"\n    }\n}\n\nconst RANDOM_BASE_URL = \"https://example.com\"\n\nfunction isUrl(url: string): boolean {\n    try {\n        return (\n            url === encodeURIComponent(url) \n            && !!(new URL(url, RANDOM_BASE_URL))\n        )\n    } catch {\n        return false\n    }\n}\n\nexport function validateManifest<T>(cargo: T): ValidatedCodeManfiest {\n    \n    const out: ValidatedCodeManfiest = {\n        pkg: new HuzmaManifest(),\n        errors: [],\n        semanticVersion: SemVer.null()\n    }\n    const {pkg, errors} = out\n    const c = cargo as ManifestOptions\n    const baseType = betterTypeof(c)\n    if (baseType !== \"object\") {\n        errors.push(`expected cargo to be type \"object\" got \"${baseType}\"`)\n        return out\n    }\n\n    if (\n        typeof c.schema !== \"number\"\n        || c.schema < FIRST_SCHEMA_VERSION\n        || c.schema > LATEST_SCHEMA_VERSION\n    ) {\n        const validVersions = new Array<number>(2)\n            .fill(0)\n            .map((_, index) => index + 1)\n        errors.push(`crate version is invalid, got \"${c.schema}\", valid=${validVersions.join(\", \")}`)\n    }\n    pkg.schema = c.schema || LATEST_SCHEMA_VERSION\n\n    if (!typevalid(c, \"name\", \"string\", errors)) {}\n    pkg.name = orNull(c.name)\n\n    let semverTmp: SemVer | null\n    if (!typevalid(c, \"version\", \"string\", errors)) {\n\n    } else if (!(semverTmp = SemVer.fromString(c.version || \"\"))) {\n        errors.push(`${c.version} is not a vaild semantic version`)\n    } else {\n        out.semanticVersion = semverTmp\n    }\n    pkg.version = orNull(c.version)\n\n    const targetFiles = c.files === undefined ? [] : c.files\n    const filesIsArray = Array.isArray(targetFiles)\n    if (!filesIsArray) {\n        errors.push(`files should be an array, got \"${betterTypeof(targetFiles)}\"`)\n    }\n    \n    const fileRecord: Map<string, boolean> = new Map()\n    const files = !filesIsArray ? [] : targetFiles\n    for (let i = 0; i < files.length; i++) {\n        const preFile = files[i]\n        if (typeof preFile === \"string\") {\n            if (!isUrl(preFile)) {\n                errors.push(`files should be a valid url. got \"${preFile}\"`)\n            }\n            files[i] = {name: preFile, bytes: 0, invalidation: \"default\"}\n        }\n        const file = files[i] as Partial<{name: string, bytes: 0, invalidation: string}>\n        if (betterTypeof(file) !== \"object\") {\n            errors.push(`file ${i} is not an object. Expected an object with a \"name\" field, got ${betterTypeof(file)}`)\n            break\n        }\n        if (typeof file?.name !== \"string\" || !isUrl(file.name)) {\n            errors.push(`file ${i} is not a valid file format, file.name and must be a valid absolute or relative url. got ${file.name}`)\n            break\n        }\n\n        if (typeof (file?.invalidation || \"\") !== \"string\") {\n            errors.push(`file ${i} is not a valid file format, file.invalidation must be a string`)\n            break\n        }\n\n        const stdName = stripRelativePath(file.name)\n        // ignore duplicate files\n        if (fileRecord.has(stdName)) {\n            break\n        }\n        fileRecord.set(stdName, true)\n        pkg.files.push({\n            name: stdName,\n            bytes: Math.max(\n                typeof file.bytes === \"number\" ? file.bytes : BYTES_NOT_INCLUDED, \n                BYTES_NOT_INCLUDED\n            ),\n            invalidation: toInvalidation(\n                file?.invalidation || \"default\"\n            )\n        })\n    }\n\n    const permissions = c.permissions || []\n    if (!Array.isArray(permissions)) {\n        errors.push(`permissions should be an array, got \"${betterTypeof(c.permissions)}\"`)\n    }\n\n    const permissionsMap = new Map<string, number>()\n    for (let i = 0; i < permissions.length; i++) {\n        const permission = permissions[i]\n        const permissionType = betterTypeof(permission)\n        if (permissionType !== \"string\" && permissionType !== \"object\") {\n            errors.push(`permission should be a string or object with \"key\" & \"value\" properties. Permission ${i} type=${betterTypeof(permission)}`)\n        }\n\n        if (typeof permission === \"string\") {\n            if (permissionsMap.has(permission)) {\n                continue\n            }\n            permissionsMap.set(permission, 1)\n            pkg.permissions.push({key: permission, value: []})\n            continue\n        }\n        if (permissionType !== \"object\") {\n            continue\n        }\n        if (typeof permission.key !== \"string\") {\n            errors.push(`permission ${i} property \"key\" is not a string. got = ${betterTypeof(permission.key)}`)\n            continue\n        }\n        const value = permission.value || []\n        if (!Array.isArray(value)) {\n            errors.push(`permission ${i} property \"value\" is not an array. got = ${betterTypeof(permission.key)}`)\n            continue\n        }\n        if (permissionsMap.has(permission.key)) {\n            continue\n        }\n        permissionsMap.set(permission.key, 1)\n        pkg.permissions.push({\n            key: permission.key, \n            value: value.filter((val) => typeof val === \"string\")\n        })\n    }\n\n    c.entry = orNull(c.entry)\n    if (!typevalid(c, \"entry\", \"string\", errors)) {}\n    if (c.entry !== NULL_FIELD && !isUrl(c.entry)) {\n        errors.push(`entry field must be a valid relative or absolute url. got \"${pkg.entry}\"`)\n    }\n    pkg.entry = c.entry\n\n    pkg.invalidation = typeof c.invalidation === \"string\"\n        ? toInvalidation(c.invalidation)\n        : \"default\"\n    pkg.description = orNull(c.description)\n    pkg.authors = (c.authors || [])\n        .filter(a => typeof a?.name === \"string\")\n        .map(({name = \"\", email, url}) => ({\n            name,  email: orNull(email), url: orNull(url)\n        }))\n    pkg.crateLogoUrl = stripRelativePath(orNull(c.crateLogoUrl))\n    pkg.keywords = (c.keywords || [])\n        .filter(w => typeof w === \"string\")\n    pkg.license = orNull(c.license)\n    pkg.repo.type = orNull(c.repo?.type)\n    pkg.repo.url = orNull(c.repo?.url)\n    pkg.homepageUrl = orNull(c.homepageUrl)\n\n    c.metadata = c.metadata || {}\n    if (betterTypeof(c.metadata) !== \"object\") {\n        errors.push(`metadata should be a record of strings, got \"${betterTypeof(c.metadata)}\"`)\n        c.metadata = {}\n    }\n\n    const meta: Record<string, string> = {}\n    const candidate = c.metadata || {}\n    const metaKeys = Object.keys(c.metadata || {})\n    for (let i = 0; i < metaKeys.length; i++) {\n        const key = metaKeys[i]\n        const value = candidate[key]\n        if (typeof value !== \"string\") {\n            errors.push(`meta should be a record of strings, got type \"${betterTypeof(value)}\" for property \"${key}\" of meta`)\n            continue\n        }\n        meta[key] = value\n    }\n    pkg.metadata = meta\n    return out\n}\n\nexport type ManifestUpdateResponse = {\n    oldManifest: ValidatedCodeManfiest\n    newManifest: ValidatedCodeManfiest\n    updateAvailable: boolean\n}\n\nexport function manifestIsUpdatable(\n    newManifest: unknown, \n    oldManifest: unknown\n): ManifestUpdateResponse {\n    const validatedOld = validateManifest(oldManifest)\n    const validatedNew = validateManifest(newManifest)\n    const out = {\n        oldManifest: validatedOld, \n        newManifest: validatedNew,\n        updateAvailable: false\n    }\n    const oldErrs = out.oldManifest.errors.length > 0\n    const newErrs = out.oldManifest.errors.length > 0\n    if (oldErrs || newErrs) {\n        return out\n    }\n    const oldVersionIsNull = validatedOld.pkg.version === NULL_MANIFEST_VERSION\n    const newVersionIsNull = validatedNew.pkg.version === NULL_MANIFEST_VERSION\n    if (oldVersionIsNull && newVersionIsNull) {\n        return out\n    } else if (newVersionIsNull) {\n        return out\n    } else if (oldVersionIsNull && !newVersionIsNull) {\n        out.updateAvailable = true\n        return out\n    }\n    const oldSemVer = validatedOld.semanticVersion\n    const newSemver = validatedNew.semanticVersion\n    out.updateAvailable = newSemver.isGreater(oldSemVer)\n    return out\n}\n\nexport type FileRef = {\n    name: string, \n    bytes: number\n}\n\nexport class HuzmaUpdateDetails {\n    add: FileRef[]\n    delete: FileRef[]\n\n    constructor(addFiles: FileRef[], deleteFiles: FileRef[]) {\n        this.add = addFiles\n        this.delete = deleteFiles\n    }\n}\n\nexport function diffManifestFiles(\n    newCargo: HuzmaManifest, \n    oldCargo: HuzmaManifest,\n    defaultInvalidation: ValidDefaultStrategies\n): HuzmaUpdateDetails {\n    const updates = new HuzmaUpdateDetails([], [])\n    const newFiles: Record<string, ValidDefaultStrategies> = {}\n    for (let i = 0; i < newCargo.files.length; i++) {\n        const {name, invalidation} = newCargo.files[i]\n        if (\n            newCargo.entry !== NULL_FIELD \n            && name === newCargo.entry\n            && invalidation === \"default\"\n        ) {\n            newFiles[name] = \"purge\"\n            continue\n        }\n        newFiles[name] = invalidation === \"default\"\n            ? defaultInvalidation\n            : invalidation\n    }\n\n    const oldFiles: Record<string, boolean> = {}\n    for (let i = 0; i < oldCargo.files.length; i++) {\n        const {name} = oldCargo.files[i]\n        oldFiles[name] = true\n    }\n\n    for (let i = 0; i < newCargo.files.length; i++) {\n        const {name, bytes} = newCargo.files[i]\n        if (!oldFiles[name] || newFiles[name] === \"purge\") {\n            updates.add.push({name, bytes})\n        }\n    }\n\n    for (let i = 0; i < oldCargo.files.length; i++) {\n        const {name, bytes} = oldCargo.files[i]\n        const invalidation = newFiles[name]\n        if (!invalidation || invalidation === \"purge\") {\n            updates.delete.push({name, bytes})\n        }\n    }\n    return updates\n}"],
  "mappings": "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",
  "names": ["SemVer", "betterTypeof", "val", "t", "stripRelativePath", "url", "split", "urlStart", "path", "schema", "name", "version", "files", "entry", "invalidation", "description", "authors", "crateLogoUrl", "keywords", "license", "repo", "homepageUrl", "permissions", "metadata", "email", "file", "bytes", "permissionsExpanded", "permission", "permissionsMap", "noDuplicates", "permissionsArray", "next", "orNull", "str", "typevalid", "obj", "key", "type", "errs", "toInvalidation", "RANDOM_BASE_URL", "isUrl", "cargo", "out", "pkg", "errors", "c", "baseType", "validVersions", "_", "index", "semverTmp", "targetFiles", "filesIsArray", "fileRecord", "i", "preFile", "stdName", "permissionType", "value", "a", "w", "meta", "candidate", "metaKeys", "newManifest", "oldManifest", "validatedOld", "validatedNew", "oldErrs", "newErrs", "oldVersionIsNull", "newVersionIsNull", "oldSemVer", "newSemver", "addFiles", "deleteFiles", "newCargo", "oldCargo", "defaultInvalidation", "updates", "newFiles", "oldFiles"]
}
